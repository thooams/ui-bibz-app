:markdown
  # Tables

  The `table_card` component may comprise :

  * a pagination
  * an url

  The pagegination is managed through the gem `will_paginate` .

  The methods of `will_paginate` work with the `table` component such as `per_page` .

%important
  :markdown
    #### Important
    To add, edit, delete columns and actions in the component `table_card` you must add the option `tap: true`.

- @sections = sections do |s|
  - s.section title: "Model" do

    %p Insert in the model the following line :
    = example do |c|
      - c.code do
        class MyModel < ActiveRecord::Base
          include UiBibz::Concerns::Models::Searchable
          ...
        end

  - s.section title: "Controller" do
    :markdown
      Use the method in your model `table_search_pagination` passing arguments :

      * params
      * session
      * opts (optional)
    = example do |c|
      - c.code do
        class MyController < ApplicationController
          def index
            @users = MyModel.all.table_search_pagination(params, session)
            ...
          end
          ...
        end

  - s.section title: "View" do
    :markdown
      The columns are all displayed by default and the default actions are:

      * show
      * edit
      * delete
    = example do |c|
      - c.header do
        = table({ store: @users, tap: true }) do |b|
          - b.columns do |cls|
            - cls.column :id
            - cls.column :email
            - cls.column :active
            - cls.column :company
            - cls.column :created_at
            - cls.column :updated_at
          - b.actions do |acs|
            - acs.link 'Show', url: '#show', glyph: 'eye'
            - acs.link 'Edit', url: '#show', glyph: 'pencil'
            - acs.link 'Delete', url: '#show', glyph: 'trash',  link_html_options: { data: { confirm: 'Are you sure?' }}
      - c.code do
        table store: @users
      - c.footer do
        = documentation_link 'Documentation', '#'

  - s.section title: "Table Columns" do
    :markdown
      Adding columns through the column method contains several arguments and this method is based on the component :

      * data_index (symbol)
      * options (hash)
        * name (the name of the column)
        * count (uses the count method on the element)
        * date_format (formats the date display using the strftime method ex: `%Y/%M/%D`)
        * format (formats the elements of colone using lambda)
        * link (adds a link where the expression `:id` is parsed and replaced with the corresponding integer)
        * sort (to sort on fields)
        * column_id (identifies the column can be useful for the spell)
        * custom_sort (indicates the table will be sorted in a customized way)
      * html_options (hash)
    = example do |c|
      - c.header do
        = table({ store: @users, tap: true }) do |b|
          - b.columns do |cls|
            - cls.column :id, name: '#'
            - cls.column :email, link: '#email'
            - cls.column :active, format: lambda { |records, record| active_icon(record) }
            - cls.column :company
            - cls.column :created_at, date_format: '%d/%M/%Y'
            - cls.column :updated_at
          - b.actions do |acs|
            - acs.link 'Show', url: '#show', glyph: 'eye'
            - acs.link 'Edit', url: '#show', glyph: 'pencil'
            - acs.link 'Delete', url: '#show', glyph: 'trash',  link_html_options: { data: { confirm: 'Are you sure?' }}
      - c.code do
        table({ store: @users, tap: true }) do |b|
          b.columns do |cls|
            cls.column :id, name: '#'
            cls.column :email, link: '#email'
            cls.column :active, format: lambda { |records, record| active_icon(record) }
            cls.column :company
            cls.column :created_at, date_format: '%d/%M/%Y'
            cls.column :updated_at
          end
        end
      - c.footer do
        = documentation_link 'Documentation', '#'


  - s.section title: "Table Actions" do
    :markdown
      The shares are included in a dropdown button.
      These shares inherit the `DropdownLink` component and provides the following methods :

      * [Header](../components/dropdowns#header)
      * [Divider](../components/dropdowns#divider)
      * [Link](../components/dropdowns#link)
      * [Html](../components/dropdowns#html)

      If no action is added, actions by faults are displayed.
      You can activate them through the `default_actions option: false`.
      The `link` option can inject the id of the record by writing in your `link id`.

    = example do |c|
      - c.header do
        = table({ store: @users, tap: true }) do |b|
          - b.columns do |cls|
            - cls.column :id
            - cls.column :email
            - cls.column :active
            - cls.column :company
            - cls.column :created_at
            - cls.column :updated_at
          - b.actions do |acs|
            - acs.link 'Open', url: "#open", glyph: 'folder-open'
            - acs.link 'Close', url: "#close", glyph: 'folder'
            - acs.link 'Delete', url: "#delete", glyph: 'trash',  link_html_options: { data: { confirm: 'Are you sure?' }}
      - c.code do
        table({ store: @users, tap: true }) do |b|
          b.actions do |acs|
            acs.link 'Open', url: open_user_path(:id), glyph: 'folder-open'
            acs.link 'Close', url: close_user_path(:id), glyph: 'folder'
            acs.link 'Delete', url: user_path(:id), glyph: 'trash',  link_html_options: { data: { confirm: 'Are you sure?' }}
          end
        end
      - c.footer do
        = documentation_link 'Documentation', '#'

    :markdown
      Actions can be formatted according to each line.
      With the `format` method you have access to the record to format the desired action.

    = example do |c|
      - c.header do
        = table({ store: @users, tap: true }) do |b|
          - b.columns do |cls|
            - cls.column :id
            - cls.column :email
            - cls.column :active
            - cls.column :company
            - cls.column :created_at
            - cls.column :updated_at
          - b.actions do |acs|
            - acs.format do |record|
              - acs.link 'Show', url: '#show', glyph: 'eye'
              - acs.link 'Edit', url: '#show', glyph: 'pencil'
              - acs.link 'Delete', url: '#show', glyph: 'trash',  link_html_options: { data: { confirm: 'Are you sure?' }}
              - if record.active
                - acs.link 'Active', url: '#active', glyph: 'check-circle'
              - else
                - acs.link 'Disabled', url: '#disabled'
      - c.code do
        table({ store: @users, tap: true }) do |b|
          b.actions do |acs|
            acs.format do |record|
              acs.link 'Show', url: user_path(:id), glyph: 'eye'
              acs.link 'Edit', url: edit_user_path(:id), glyph: 'pencil'
              acs.link 'Delete', url: user_path(:id), glyph: 'trash',  link_html_options: { data: { confirm: 'Are you sure?' }}
              if record.active?
                acs.link 'Active', { url: active_users_path(record.id) }
              else
                acs.link 'Disabled', { url: disabled_users_path(record.id) }
              end
            end
          end
        end
      - c.footer do
        = documentation_link 'Documentation', '#'


  - s.section title: "Controller arguments" do
    :markdown
      If we wish, for example, count users who have no direct link with the documents. Imagine, for example, a user with products and that these products contain several documents. We wish to count the number of users by documents.
      We can add arguments in the method `table_search_pagination` that will help to make joints.
    = example do |c|
      - c.code do
        Arguments  = { sortable: {
          column: 'users',
          count:  true,
          joins: "LEFT OUTER JOIN documents_products ON documents_products.document_id = documents.id
                  LEFT OUTER JOIN products ON products.id = documents_products.product_id
                  LEFT OUTER JOIN products_users ON products_users.product_id = products.id
                  LEFT OUTER JOIN users ON users.id = products_users.user_id"
        } }

        @documents = Document.includes(:users).table_search_pagination(params, session, arguments)
    :markdown
      Here the sortable argument means that one wishes to interresser the sorting functionality.
      For that it is necessary :

      * define the name of the column sorted through the argument column: (string)
      * determine whether the treatment is done on counting with the count argument : (boolean)
      * define the join along with the argument : (string , array , hash)

    = example do |c|
      - c.code do
        table store: @documents do |g|
          g.columns do |c|
            c.column :users, { name: 'Users count', count: true, custom_sort: true }
          end
        end

= @sections.render
