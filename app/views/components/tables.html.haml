:markdown
  # Tables

  Le composant `table` peut comporter:

  * une pagination
  * une recherche

  La pagination est gérer grâce à la gem `will_paginate`.

  Les methodes de `will_paginate` fonctionnent avec le composant `table` comme par exemple `per_page`.

%important
  :markdown
    #### Important
    Pour ajouter, modifier, supprimer des colonnes et des actions dans le component
    `table` vous devez ajouter l'option `tap: true`.


- @sections = sections do |s|
  - s.section title: "Model" do
    %p Insérer dans le model la ligne suivante:
    = example do |c|
      - c.code do
        class MyModel < ActiveRecord::Base
          include UiBibz::Concerns::Models::Searchable
          ...
        end

  - s.section title: "Controller" do
    :markdown
      Utiliser dans votre modèle la methode `table_search_pagination` en passant les arguments:

      * params
      * session
      * opts (optional)
    = example do |c|
      - c.code do
        class MyController < ApplicationController
          def index
            @users = MyModel.all.table_search_pagination(params, session)
            ...
          end
          ...
        end

  - s.section title: "View" do
    :markdown
      Les colonnes sont par défaut toutes affichées et les actions par défaut sont:

      * show
      * edit
      * delete
    = example do |c|
      - c.header do
        = table({ store: @users, tap: true }) do |b|
          - b.columns do |cls|
            - cls.column :id
            - cls.column :email
            - cls.column :active
            - cls.column :company
            - cls.column :created_at
            - cls.column :updated_at
          - b.actions do |acs|
            - acs.link 'Show', url: '#show', glyph: 'eye'
            - acs.link 'Edit', url: '#show', glyph: 'pencil'
            - acs.link 'Delete', url: '#show', glyph: 'trash',  link_html_options: { data: { confirm: 'Are you sure?' }}
      - c.code do
        table store: @users
      - c.footer do
        = documentation_link 'Documentation', '#'

  - s.section title: "Table Columns" do
    :markdown
      L'ajout de colonnes à travers la méthode column contient plusieurs arguments et cette méthode est basée sur le component :

      * data_index (symbol)
      * options (hash)
        * name (le nom de la colonne)
        * count (utilise la méthode count sur l'élément)
        * date_format (formate l'affichage de la date en utilisant la méthode strftime ex: '%Y/%M/%D')
        * format (formate les élements de la colone en utilisant lambda)
        * link (ajoute un lien où l'expression :id est parsé et remplacé par l'entier correspondant)
        * sort (permet de trier sur des champs )
        * column_id (permet d'identifier la colonne : peut être utile pour le sort)
        * custom_sort (indique que le tableau sera triéé d'une manière personnalisée)
      * html_options (hash)
    = example do |c|
      - c.header do
        = table({ store: @users, tap: true }) do |b|
          - b.columns do |cls|
            - cls.column :id, name: '#'
            - cls.column :email, link: '#email'
            - cls.column :active, format: lambda { |records, record| active_icon(record) }
            - cls.column :company
            - cls.column :created_at, date_format: '%d/%M/%Y'
            - cls.column :updated_at
          - b.actions do |acs|
            - acs.link 'Show', url: '#show', glyph: 'eye'
            - acs.link 'Edit', url: '#show', glyph: 'pencil'
            - acs.link 'Delete', url: '#show', glyph: 'trash',  link_html_options: { data: { confirm: 'Are you sure?' }}
      - c.code do
        table({ store: @users, tap: true }) do |b|
          b.columns do |cls|
            cls.column :id, name: '#'
            cls.column :email, link: '#email'
            cls.column :active, format: lambda { |records, record| active_icon(record) }
            cls.column :company
            cls.column :created_at, date_format: '%d/%M/%Y'
            cls.column :updated_at
          end
        end
      - c.footer do
        = documentation_link 'Documentation', '#'


  - s.section title: "Table Actions" do
    :markdown
      Les actions sont insérées dans un bouton dropdown.
      Ces actions héritent du composant `DropdownLink` et propose les méthodes suivantes:

      * [Header](../components/dropdowns#header)
      * [Divider](../components/dropdowns#divider)
      * [Link](../components/dropdowns#link)
      * [Html](../components/dropdowns#html)

      Si aucunes actions n'est ajoutées, les actions par défauts sont affichées.
      Vous pouvez les activer à travers l'option `default_actions: false`.
      L'option `link` peut injecter l'id du record en écrivant dans votre lien `:id`.

    = example do |c|
      - c.header do
        = table({ store: @users, tap: true }) do |b|
          - b.columns do |cls|
            - cls.column :id
            - cls.column :email
            - cls.column :active
            - cls.column :company
            - cls.column :created_at
            - cls.column :updated_at
          - b.actions do |acs|
            - acs.link 'Open', url: "#open", glyph: 'folder-open'
            - acs.link 'Close', url: "#close", glyph: 'folder'
            - acs.link 'Delete', url: "#delete", glyph: 'trash',  link_html_options: { data: { confirm: 'Are you sure?' }}
      - c.code do
        table({ store: @users, tap: true }) do |b|
          b.actions do |acs|
            acs.link 'Open', url: open_user_path(:id), glyph: 'folder-open'
            acs.link 'Close', url: close_user_path(:id), glyph: 'folder'
            acs.link 'Delete', url: user_path(:id), glyph: 'trash',  link_html_options: { data: { confirm: 'Are you sure?' }}
          end
        end
      - c.footer do
        = documentation_link 'Documentation', '#'

    :markdown
      Les actions peuvent être formatées selon à chaque ligne.
      Grâce à la méthode `format` vous avez accès au record afin de formater l'action désirée.

    = example do |c|
      - c.header do
        = table({ store: @users, tap: true }) do |b|
          - b.columns do |cls|
            - cls.column :id
            - cls.column :email
            - cls.column :active
            - cls.column :company
            - cls.column :created_at
            - cls.column :updated_at
          - b.actions do |acs|
            - acs.format do |record|
              - acs.link 'Show', url: '#show', glyph: 'eye'
              - acs.link 'Edit', url: '#show', glyph: 'pencil'
              - acs.link 'Delete', url: '#show', glyph: 'trash',  link_html_options: { data: { confirm: 'Are you sure?' }}
              - if record.active
                - acs.link 'Active', url: '#active', glyph: 'check-circle'
              - else
                - acs.link 'Disabled', url: '#disabled'
      - c.code do
        table({ store: @users, tap: true }) do |b|
          b.actions do |acs|
            acs.format do |record|
              acs.link 'Show', url: user_path(:id), glyph: 'eye'
              acs.link 'Edit', url: edit_user_path(:id), glyph: 'pencil'
              acs.link 'Delete', url: user_path(:id), glyph: 'trash',  link_html_options: { data: { confirm: 'Are you sure?' }}
              if record.active?
                acs.link 'Active', { url: active_users_path(record.id) }
              else
                acs.link 'Disabled', { url: disabled_users_path(record.id) }
              end
            end
          end
        end
      - c.footer do
        = documentation_link 'Documentation', '#'


  - s.section title: "Controller arguments" do
    :markdown
      Si l'on souhaite, par exemple, dénombrer des utilisateurs qui ont un lien non direct avec les documents. Imaginons par exemple, un utilisateur à des produits et que ces produits contiennent plusieurs documents. On souhaite compter le nombre d'utilisateurs par documents.
      On peut ajouter des arguments dans la méthode `table_search_pagination` qui vont permettre de faire des jointures.
    = example do |c|
      - c.code do
        Arguments  = { sortable: {
          column: 'users',
          count:  true,
          joins: "LEFT OUTER JOIN documents_products ON documents_products.document_id = documents.id
                  LEFT OUTER JOIN products ON products.id = documents_products.product_id
                  LEFT OUTER JOIN products_users ON products_users.product_id = products.id
                  LEFT OUTER JOIN users ON users.id = products_users.user_id"
        } }

        @documents = Document.includes(:users).table_search_pagination(params, session, arguments)
    :markdown
      Ici l'argument sortable signifie que l'on souhaite s'interresser à la fonctionnalité de trie.
      Pour celà il faut :

      * définir le nom de la colonne triéé à travers l'argument column: (string)
      * définir si le traitement se fait sur le comptage avec l'argument count: (boolean)
      * définir la jointure avec l'argument joins: (string, array, hash)


    = example do |c|
      - c.code do
        table store: @documents do |g|
          g.columns do |c|
            c.column :users, { name: 'Users count', count: true, custom_sort: true }
          end
        end

= @sections.render
